import streamlit as st
import subprocess
import tempfile
import os
import re
import shutil
from pathlib import Path

INPUT_BLOCKS = [
    {"Block": "autoci", "Description": "Autogenerated single- and multi-reference correlation methods"},
    {"Block": "basis", "Description": "Basis sets"},
    {"Block": "casresp", "Description": "CASSCF static linear response"},
    {"Block": "casscf", "Description": "CASSCF/NEVPT2 and DMRG calculations"},
    {"Block": "chelpg", "Description": "CHELPG charges"},
    {"Block": "cim", "Description": "Cluster-in-molecules calculations"},
    {"Block": "cis (tddft)", "Description": "CIS and TD-DFT calculations"},
    {"Block": "compound", "Description": "Compound jobs"},
    {"Block": "conical", "Description": "Optimization of conical intersections"},
    {"Block": "coords", "Description": "Input of atomic coordinates"},
    {"Block": "cosmors", "Description": "OpenCOSMO-RS options"},
    {"Block": "cpcm", "Description": "Conductor-like Polarizable Continuum Model"},
    {"Block": "docker", "Description": "Host-guest docking algorithm"},
    {"Block": "eda", "Description": "Energy decomposition analysis"},
    {"Block": "elprop", "Description": "Electric properties"},
    {"Block": "eprnmr", "Description": "EPR and NMR properties"},
    {"Block": "esd", "Description": "Excited state dynamics"},
    {"Block": "frag", "Description": "Automatic fragmentation procedure"},
    {"Block": "freq", "Description": "Vibrational frequencies"},
    {"Block": "geom", "Description": "Geometry optimization"},
    {"Block": "goat", "Description": "Global optimization algorithm"},
    {"Block": "ice (iceci,cipsi)", "Description": "Iterative configuration expansion CI calculations"},
    {"Block": "irc", "Description": "Intrinsic reaction coordinate calculations"},
    {"Block": "lft", "Description": "Ligand field theory utility orca_lft"},
    {"Block": "loc", "Description": "Localization of orbitals"},
    {"Block": "mcrpa", "Description": "CASSCF linear response"},
    {"Block": "md", "Description": "Molecular dynamics"},
    {"Block": "mdci", "Description": "Single reference correlation methods"},
    {"Block": "mecp", "Description": "Minimum energy crossing points optimization"},
    {"Block": "method", "Description": "Choice of computation method and options"},
    {"Block": "mm", "Description": "Molecular mechanics force-fields"},
    {"Block": "mp2", "Description": "MP2 calculations"},
    {"Block": "mrcc", "Description": "Multi-reference CC calculations"},
    {"Block": "mrci", "Description": "Multi-reference CI calculations"},
    {"Block": "mtr", "Description": "Normal mode trajectory/scan"},
    {"Block": "nbo", "Description": "NBO analysis"},
    {"Block": "ndoparas", "Description": "Parameters for NDO-based semi-empirical methods"},
    {"Block": "neb", "Description": "NEB calculations"},
    {"Block": "numgrad", "Description": "Numerical gradients"},
    {"Block": "output", "Description": "Control of output"},
    {"Block": "pal", "Description": "Parallel jobs"},
    {"Block": "paras", "Description": "Input of geometric parameters"},
    {"Block": "plots", "Description": "Plot generation"},
    {"Block": "qmmm", "Description": "Multiscale (QM/MM) calculations"},
    {"Block": "rel", "Description": "Relativistic options"},
    {"Block": "rocis", "Description": "Restricted-open-shell CIS"},
    {"Block": "rr", "Description": "Resonance Raman and absorption/fluorescence band-shape"},
    {"Block": "scf", "Description": "SCF procedure settings"},
    {"Block": "shark", "Description": "SHARK integral package"},
    {"Block": "solvator", "Description": "Explicit solvation algorithm"},
    {"Block": "symmetry (sym)", "Description": "Spatial symmetry recognition"},
    {"Block": "vpt2", "Description": "Vibrational perturbation theory"},
    {"Block": "xtb", "Description": "Options for the xtb program interface"},
]

SINGLE_LINE_KEYWORDS = [
    {"Keyword": "base", "Value": "<BaseName>", "Description": "Base name for output files"},
    {"Keyword": "cclib", "Value": "<FileName>", "Description": "File with one-particle coupling coefficients for ICE-CI"},
    {"Keyword": "id", "Value": "<string>", "Description": "Deprecated identifier for job summaries"},
    {"Keyword": "ljcoefficients", "Value": "<FileName>", "Description": "Lennard-Jones coefficients for PHVA"},
    {"Keyword": "maxcore", "Value": "4096", "Description": "Maximum heap memory to use in MB"},
    {"Keyword": "moinp", "Value": "<FileName>", "Description": "GBW file for MORead guess"},
    {"Keyword": "pointcharges", "Value": "<FileName>", "Description": "External point charges file"},
]

def check_orca_installation():
    """Check if ORCA is installed and accessible."""
    try:
        result = subprocess.run(['which', 'orca'], 
                              capture_output=True, 
                              text=True, 
                              timeout=10)
        if result.returncode == 0 and result.stdout.strip():
            orca_path = result.stdout.strip()
            return True, f"ORCA installation found"
        else:
            return False, "ORCA is not installed or not accessible via command line"
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False, "ORCA is not installed or not accessible via command line"

def generate_orca_input(geometry, method="B3LYP", basis="def2-SVP", calculation_type="Opt", charge=0, multiplicity=1, units="Angs"):
    """Generate ORCA input file content for simple XYZ coordinates.

    Parameters
    ----------
    geometry : str
        XYZ coordinate block (one atom per line).
    method : str
        Electronic structure method (e.g. B3LYP).
    basis : str
        Orbital basis set (e.g. def2-SVP).
    calculation_type : str
        Job type keyword for ORCA simple input (e.g. Opt).
    charge : int
        Total molecular charge.
    multiplicity : int
        Spin multiplicity (2S+1).
    units : str
        Coordinate units; "Angs" (default) or "Bohrs". For Bohrs a
        corresponding simple keyword is added.
    """
    units_keyword = ""
    if units.lower().startswith("bohr"):
        # Only add explicit units keyword when using Bohrs; Angstrom is default
        units_keyword = " Bohrs"

    input_content = f"""! {method} {basis} {calculation_type}{units_keyword}

* xyz {charge} {multiplicity}
{geometry}
*
"""
    return input_content

def parse_orca_input_geometry(input_content):
    """Extract geometry, charge, and multiplicity from ORCA input content."""
    pattern = r"\*\s*xyz\s+([-+]?\d+)\s+(\d+)\s*\n(.*?)\n\*"
    match = re.search(pattern, input_content, re.IGNORECASE | re.DOTALL)
    if not match:
        return None, None, None
    charge = match.group(1)
    multiplicity = match.group(2)
    geometry_block = match.group(3).strip()
    geometry_lines = []
    for line in geometry_block.split("\n"):
        parts = line.split()
        if len(parts) >= 4:
            geometry_lines.append(f"{parts[0]} {parts[1]} {parts[2]} {parts[3]}")
    geometry = "\n".join(geometry_lines).strip() if geometry_lines else None
    return geometry, charge, multiplicity

def parse_xyz_content(xyz_content):
    """Parse XYZ file content into ORCA geometry block."""
    lines = [line.strip() for line in xyz_content.splitlines() if line.strip()]
    if not lines:
        return "", "XYZ file is empty."
    if re.match(r"^\d+$", lines[0]):
        if len(lines) < 3:
            return "", "XYZ file is missing coordinate lines."
        lines = lines[2:]
    geometry_lines = []
    for line in lines:
        parts = line.split()
        if len(parts) < 4:
            return "", f"Invalid XYZ line: '{line}'"
        try:
            float(parts[1])
            float(parts[2])
            float(parts[3])
        except ValueError:
            return "", f"Invalid XYZ coordinates in line: '{line}'"
        geometry_lines.append(f"{parts[0]} {parts[1]} {parts[2]} {parts[3]}")
    return "\n".join(geometry_lines), None

def validate_orca_input(input_content):
    """Validate basic ORCA input structure and return a list of errors."""
    errors = []
    if not input_content.strip():
        return ["Input content is empty."]
    match = re.search(r"\*\s*xyz\s+([-+]?\d+)\s+(\d+)\s*\n(.*?)\n\*", input_content, re.IGNORECASE | re.DOTALL)
    if not match:
        errors.append("Missing or malformed '* xyz CHARGE MULTIPLICITY' block.")
        return errors
    try:
        int(match.group(1))
        int(match.group(2))
    except ValueError:
        errors.append("Charge or multiplicity is not an integer.")
    geometry_block = match.group(3).strip()
    if not geometry_block:
        errors.append("Geometry block is empty.")
        return errors
    for line in geometry_block.split("\n"):
        parts = line.split()
        if len(parts) < 4:
            errors.append(f"Invalid geometry line: '{line}'")
            continue
        try:
            float(parts[1])
            float(parts[2])
            float(parts[3])
        except ValueError:
            errors.append(f"Invalid coordinates in line: '{line}'")
    return errors

def run_orca_calculation(input_content, temp_dir):
    """Run ORCA calculation and return output file path."""
    input_file = os.path.join(temp_dir, "calculation.inp")
    output_file = os.path.join(temp_dir, "calculation.out")
    
    # Write input file
    with open(input_file, 'w') as f:
        f.write(input_content)
    
    # Run ORCA calculation with shell redirection (as per ORCA manual)
    # ORCA writes to stdout/stderr which must be redirected to output file
    try:
        # Use shell=True to enable redirection: orca input.inp >& output.out
        command = f"orca {input_file} >& {output_file}"
        result = subprocess.run(command,
                              shell=True,
                              cwd=temp_dir,
                              timeout=300)  # 5 minute timeout
        
        # Check if output file was created
        if not os.path.exists(output_file):
            files_created = os.listdir(temp_dir)
            error_msg = f"ORCA did not create output file.\nReturn code: {result.returncode}\n"
            error_msg += f"Files in temp directory: {files_created}\n"
            return False, output_file, error_msg
        
        # Read output file to check for errors
        with open(output_file, 'r') as f:
            output_content = f.read()
        
        # Check if calculation terminated normally
        if "ORCA TERMINATED NORMALLY" not in output_content:
            return False, output_file, f"ORCA did not terminate normally. Check output file for errors."
        
        return True, output_file, output_content
    except subprocess.TimeoutExpired:
        return False, output_file, "Calculation timed out after 5 minutes"
    except Exception as e:
        return False, output_file, str(e)

def parse_orca_output(output_file):
    """Parse ORCA output file for energy and optimized geometry."""
    try:
        with open(output_file, 'r') as f:
            content = f.read()
        
        # Parse final energy - look for "FINAL SINGLE POINT ENERGY"
        energy_pattern = r'FINAL SINGLE POINT ENERGY\s+([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)'
        energy_match = re.search(energy_pattern, content)
        
        if energy_match:
            energy = energy_match.group(1)
        else:
            energy = "Not found"
        
        # Parse optimized geometry - look for the last CARTESIAN COORDINATES section
        geometry_pattern = r'CARTESIAN COORDINATES \(ANGSTROEM\)\s*-+\s*\n((?:.*\n)*?)(?=-{3,}|\n\s*\n)'
        geometry_matches = re.findall(geometry_pattern, content)
        
        if geometry_matches:
            # Get the last geometry (optimized)
            geometry_text = geometry_matches[-1].strip()
            # Extract atom coordinates
            atom_lines = []
            for line in geometry_text.split('\n'):
                line = line.strip()
                if line and not line.startswith('-'):
                    parts = line.split()
                    if len(parts) >= 4:
                        try:
                            # Check if we can parse the coordinates
                            float(parts[1])
                            float(parts[2])
                            float(parts[3])
                            atom_lines.append(f"{parts[0]:2s}  {parts[1]:>12s}  {parts[2]:>12s}  {parts[3]:>12s}")
                        except (ValueError, IndexError):
                            continue
            geometry = '\n'.join(atom_lines) if atom_lines else "Not found"
        else:
            geometry = "Not found"
        
        return energy, geometry, content
    except Exception as e:
        return f"Error: {str(e)}", f"Error: {str(e)}", str(e)

def main():
    st.title("üß™ ORCA DFT Calculator")
    st.markdown("""
    Welcome to the ORCA DFT Calculator! This app performs quantum chemistry calculations using the ORCA software package.
    
    **What this app does:**
    - Performs geometry optimization using DFT (Density Functional Theory)
    - Uses the B3LYP functional with def2-SVP basis set
    - Finds the lowest energy structure of your molecule
    """)
    
    # Check ORCA installation
    st.divider()
    st.subheader("Step 1: System Check")
    st.info("Verifying ORCA installation...")
    
    orca_available, orca_info = check_orca_installation()
    if not orca_available:
        st.error(f"‚ùå ORCA Error: {orca_info}")
        st.markdown("""
        **How to fix:**
        - Make sure ORCA is installed on your system
        - Ensure ORCA is in your PATH environment variable
        - Try running `which orca` in your terminal to verify
        """)
        st.stop()
    
    st.success(f"‚úì {orca_info}")
    
    # Default water molecule geometry
    default_geometry = """O 0.0 0.0 0.0
H 0.96 0.0 0.0
H -0.24 0.93 0.0"""
    
    if "geometry_input" not in st.session_state:
        st.session_state.geometry_input = default_geometry
    if "input_mode" not in st.session_state:
        st.session_state.input_mode = "Simple XYZ (recommended)"

    # Input section
    st.divider()
    st.subheader("Step 2: Prepare ORCA Input")
    st.markdown("""
    ORCA input files are free-format ASCII and can include:
    - **Simple keywords** (lines starting with `!`)
    - **Input blocks** (start with `%` and end with `end`)
    - **Coordinates** (usually between `*` ... `*` with charge and multiplicity)
    - **Comments** (start with `#` and go to end of line)
    
    The input is **case-insensitive** (except filenames on Unix-like systems).
    """)
    st.code(
        """! METHOD BASIS OPT (HF def2-TZVP)
%scf
  convergence tight
end

* xyz 0 1
C 0.0 0.0 0.0
O 0.0 0.0 1.13
*""",
        language="text"
    )
    with st.expander("ORCA input blocks, keywords, and examples"):
        section = st.selectbox(
            "Reference section",
            [
                "Input blocks (2.1.1)",
                "Input priority & processing order (2.1.2)",
                "Global memory: MaxCore (2.1.3)",
                "Change BaseName (2.1.4)",
                "Multiple steps: $new_job (2.1.5)",
                "List of input blocks (2.1.6)",
                "Single-line % keywords (2.1.6/Table 2.2)",
                "Simple keyword lines (2.1.7)",
            ],
            help="Select a manual section to display guidance and examples."
        )

        if section == "Input blocks (2.1.1)":
            st.markdown("""
            **Input blocks** start with `%` and end with `end`.
            """)
            st.code(
                """%method
  method HF
end""",
                language="text"
            )
            st.markdown("**Variable assignment styles:**")
            st.code(
                """VariableName Value
OtherVariableName = OtherValue
Array[1] Value1
Array[1] Value1,Value2,Value3
Array Value1,Value2""",
                language="text"
            )
            st.markdown("**Arrays are 0-indexed in ORCA.**")
            st.markdown("**Strings require quotes:**")
            st.code("%scf\n  MOInp \"Myfile.gbw\"\nend", language="text")
            st.markdown("**Nested sub-blocks example:**")
            st.code(
                """%scf
  Guess PModel
  SOSCF
    start 0.002
  end
end""",
                language="text"
            )
            st.markdown("**Special syntax example:**")
            st.code("%mdci\n  MP2FragInter {1 1} {2 2}\nend", language="text")

        elif section == "Input priority & processing order (2.1.2)":
            st.markdown("""
            ORCA processes input in this order:
            1. Collects all `!` simple keyword lines into a single string.
            2. Applies known keywords in a predefined order (basis-set conflicts resolved by last keyword).
            3. Parses input blocks in the order they appear in the file.
            4. If a block keyword is duplicated, the **last value wins**.
            """)

        elif section == "Global memory: MaxCore (2.1.3)":
            st.markdown("""
            `%MaxCore` sets the memory limit **per core** in MB. Use ~75‚Äì80% of physical memory.
            """)
            st.code("%MaxCore 2000", language="text")

        elif section == "Change BaseName (2.1.4)":
            st.markdown("""
            `%base` sets the file prefix for all outputs.
            """)
            st.code('%base "job1"', language="text")

        elif section == "Multiple steps: $new_job (2.1.5)":
            st.warning("$new_job is deprecated. Use compound jobs instead.")
            st.code(
                """# First job
! LSD DEF2-SVP TightSCF

* xyz 0 2
  B 0 0 0
  O 1 0 0
*

$new_job
# Second job
! BP86 DEF2-SVP""",
                language="text"
            )

        elif section == "List of input blocks (2.1.6)":
            st.markdown("**Input block names (Table 2.1):**")
            st.dataframe(INPUT_BLOCKS, use_container_width=True, hide_index=True)

        elif section == "Single-line % keywords (2.1.6/Table 2.2)":
            st.markdown("""
            These keywords start with `%` but do **not** use `end`.
            """)
            st.dataframe(SINGLE_LINE_KEYWORDS, use_container_width=True, hide_index=True)

        else:
            st.markdown("""
            **Simple keyword lines** start with `!` and can appear anywhere in the input file:
            """)
            st.code("! Keyword1 Keyword2\n! Keyword3", language="text")
    st.markdown("""
    You can either use the guided XYZ input (recommended) or upload a full ORCA `.inp` file if you want complete control.
    """)

    # Fixed calculation parameters / basic settings (used by simple XYZ generator)
    st.divider()
    st.subheader("Step 3: Calculation Settings")
    st.markdown("""
    Basic run type and method selection. For uploaded `.inp` files, your input fully controls these settings.
    """)

    col1, col2, col3 = st.columns(3)

    # Method / functional selection (simple keywords)
    with col1:
        method_label = st.selectbox(
            "Method / functional",
            [
                "B3LYP (DFT)",
                "PBE0 (DFT)",
                "HF",
            ],
            help="Simple ORCA keywords; for more exotic methods use a custom .inp file."
        )

    # Basis set selection
    with col2:
        basis_label = st.selectbox(
            "Basis set",
            [
                "def2-SVP",
                "def2-TZVP",
            ],
            help="Standard Karlsruhe def2 basis sets."
        )

    # Run type selection (Energy / EnGrad / Opt)
    with col3:
        run_type_label = st.selectbox(
            "Run type",
            [
                "Opt (geometry optimization)",
                "Energy (single point)",
                "EnGrad (energy + gradient)",
            ],
            help="Subset of RunTyp options; for scans/MD/etc. use a custom .inp file."
        )

    # Global print level (PrintLevel in %output). Only applied in simple XYZ mode.
    printlevel_label = st.selectbox(
        "Print level (verbosity)",
        [
            "Use ORCA default",
            "mini",
            "small",
            "normal",
            "maxi",
            "large",
            "huge",
            "debug",
        ],
        help="Controls how much ORCA prints. For complex jobs, override in a custom %output block."
    )

    # Map UI labels to ORCA simple keywords
    method_map = {
        "B3LYP (DFT)": "B3LYP",
        "PBE0 (DFT)": "PBE0",
        "HF": "HF",
    }
    run_type_map = {
        "Opt (geometry optimization)": "Opt",
        "Energy (single point)": "Energy",
        "EnGrad (energy + gradient)": "EnGrad",
    }

    method_keyword = method_map[method_label]
    basis_keyword = basis_label
    run_type_keyword = run_type_map[run_type_label]

    printlevel_keyword = None if printlevel_label == "Use ORCA default" else printlevel_label

    # Use current selection from session (if any) to decide which guidance to show here.
    current_mode = st.session_state.get("input_mode", "Simple XYZ (recommended)")
    if current_mode == "Upload ORCA input file":
        st.warning("‚ö†Ô∏è Uploaded ORCA input overrides these settings. The calculation uses your file exactly as written.")
    else:
        st.info("üí° **Tip:** These defaults (B3LYP/def2-SVP/Opt) are reasonable for small organic molecules; adjust as needed.")

    # Optional reference for output and print options
    with st.expander("Output and print control (PrintLevel / %output)"):
        out_section = st.selectbox(
            "Output reference section",
            [
                "PrintLevel presets",
                "%output Print[...] flags (subset)",
                "Simple output keywords",
            ],
            help="Summarized options from the ORCA manual for controlling output."
        )

        if out_section == "PrintLevel presets":
            st.markdown(
                """**PrintLevel options (from `%output`):**

| Level   | Typical use                             |
|:--------|:----------------------------------------|
| mini    | Very compact output                     |
| small   | Reduced output (often default)          |
| normal  | Standard detailed output                |
| maxi    | More detail (MOs, densities, basis)     |
| large   | Very verbose                            |
| huge    | Matrices and detailed SCF data          |
| debug   | Everything, including debug information |
"""
            )
        elif out_section == "%output Print[...] flags (subset)":
            st.markdown(
                """**Common `Print[ <option> ]` flags in `%output`:**

```orca
%output
  PrintLevel small          # base print level
  Print[ P_InputFile ]   1  # echo the input file
  Print[ P_Cartesian ]   1  # print Cartesian coordinates
  Print[ P_Internal ]    1  # print internal coordinates
  Print[ P_Basis ]       1  # basis set summary
  Print[ P_OrbEn ]       2  # all orbital energies
  Print[ P_MOs ]         1  # MO coefficients on convergence
  Print[ P_SCFIterInfo ] 2  # more verbose SCF iteration info
  Print[ P_Mayer ]       1  # Mayer analysis
  Print[ P_Mulliken ]    1  # Mulliken analysis
  Print[ P_Loewdin ]     1  # L√∂wdin analysis
end
```
"""
            )
        else:
            st.markdown(
                """**Simple output-related keywords (shortcuts):**

```orca
! SmallPrint        # PrintLevel small
! MiniPrint         # PrintLevel mini
! NormalPrint       # PrintLevel normal

! PrintMOs          # Print[ P_MOs ]
! PrintBasis        # Print[ P_Basis ]
! PrintGap          # Print[ P_HomoLumoGap ] each SCF iteration

! XYZFILE           # write final coordinates to XYZ
! PDBFILE           # write final coordinates to PDB
! UNO               # write natural orbitals (UHF NOs)
! NoPropFile        # do not write the property file
```
"""
            )

    # Mode selection and input construction
    input_mode = st.radio(
        "Choose how to provide input:",
        ["Simple XYZ (recommended)", "Upload ORCA input file"],
        horizontal=True,
        key="input_mode",
        help="The upload option lets you provide a fully custom ORCA input file."
    )

    input_content = ""
    if input_mode == "Simple XYZ (recommended)":
        st.markdown("""
        Enter the molecular geometry in XYZ format. Each line represents one atom with its coordinates.
        """)
        col_charge, col_mult, col_units = st.columns(3)
        with col_charge:
            charge = st.number_input(
                "Total charge",
                value=0,
                step=1,
                help="Molecular charge used in the '* xyz CHARGE MULTIPLICITY' line."
            )
        with col_mult:
            multiplicity = st.number_input(
                "Spin multiplicity (2S+1)",
                value=1,
                min_value=1,
                step=1,
                help="Spin state: 1=singlet, 2=doublet, 3=triplet, ..."
            )
        with col_units:
            units_label = st.selectbox(
                "Coordinate units",
                ["Angstrom (Angs)", "Bohr (Bohrs)"],
                help="ORCA defaults to Angstroms; Bohrs can be requested via a simple keyword."
            )
        units = "Angs" if units_label.startswith("Angstrom") else "Bohrs"
        xyz_upload = st.file_uploader(
            "Upload XYZ file (optional)",
            type=["xyz"],
            help="If provided, the XYZ file will populate the coordinate field below."
        )
        if xyz_upload is not None:
            xyz_content = xyz_upload.read().decode("utf-8")
            parsed_geometry, xyz_error = parse_xyz_content(xyz_content)
            if xyz_error:
                st.error(f"‚ùå XYZ upload error: {xyz_error}")
            else:
                st.session_state.geometry_input = parsed_geometry
                st.success("‚úÖ XYZ file loaded into the coordinate field.")
        geometry_input = st.text_area(
            "Molecular coordinates:",
            key="geometry_input",
            height=150,
            help="Format: Element x y z (one atom per line, coordinates in Angstroms)"
        )
        
        # Show atom count
        atom_count = len([line for line in geometry_input.strip().split('\n') if line.strip()])
        st.caption(f"üìä Number of atoms: {atom_count}")
        
        base_input = generate_orca_input(
            geometry=geometry_input,
            method=method_keyword,
            basis=basis_keyword,
            calculation_type=run_type_keyword,
            charge=int(charge),
            multiplicity=int(multiplicity),
            units=units,
        )
        # Prepend an optional %output block if a PrintLevel was chosen
        if printlevel_keyword:
            input_content = f"%output\n  PrintLevel {printlevel_keyword}\nend\n\n" + base_input
        else:
            input_content = base_input
        st.markdown("**Generated ORCA input preview:**")
        st.code(input_content, language="text")
    else:
        uploaded_input = st.file_uploader(
            "Upload ORCA input file (.inp or .txt)",
            type=["inp", "txt"],
            help="Upload a complete ORCA input file to run exactly as written."
        )
        if uploaded_input is not None:
            input_content = uploaded_input.read().decode("utf-8")
            geometry_from_input, charge, multiplicity = parse_orca_input_geometry(input_content)
            if geometry_from_input:
                st.session_state.geometry_input = geometry_from_input
                st.success("‚úÖ Geometry extracted from uploaded input and added to the XYZ field.")
                st.caption(f"Parsed charge/multiplicity: {charge} / {multiplicity}")
            else:
                st.warning("‚ö†Ô∏è Could not locate an '* xyz' block to auto-fill geometry.")
            st.markdown("**Uploaded ORCA input preview:**")
            st.code(input_content, language="text")
        else:
            input_content = ""
            st.info("Upload an ORCA input file to continue.")
    
    # Run calculation button
    st.divider()
    st.subheader("Step 4: Run Calculation")
    st.markdown("Click the button below to start the quantum chemistry calculation.")
    
    if st.button("üöÄ Run Calculation", type="primary", use_container_width=True):
        if not input_content.strip():
            st.error("‚ùå Please provide ORCA input (either XYZ or an uploaded .inp file)")
            return

        # For the guided XYZ mode we can safely run a strict validation
        # that expects a '* xyz CHARGE MULTIPLICITY' block.
        #
        # For uploaded .inp files we deliberately skip this strict check to
        # allow internal coordinates, %coords blocks, scans, point charges, etc.,
        # and let ORCA itself validate the full input.
        if input_mode == "Simple XYZ (recommended)":
            validation_errors = validate_orca_input(input_content)
            if validation_errors:
                st.error("‚ùå ORCA input validation failed:")
                st.markdown("\n".join([f"- {error}" for error in validation_errors]))
                return
        
        # Create temporary directory
        with tempfile.TemporaryDirectory() as temp_dir:
            with st.status("Running ORCA calculation...", expanded=True) as status:
                st.write("üìù Preparing ORCA input file...")
                
                st.write("‚öôÔ∏è Executing ORCA calculation...")
                st.caption("This may take a few seconds to several minutes depending on molecule size")
                
                # Run calculation
                success, output_file, message = run_orca_calculation(input_content, temp_dir)
                
                if not success:
                    status.update(label="‚ùå Calculation failed", state="error")
                    st.error(f"Calculation failed: {message}")
                    return
                
                st.write("‚úÖ Parsing results...")
                status.update(label="‚úÖ Calculation completed successfully!", state="complete")
            
            # Parse results
            energy, optimized_geometry, full_output = parse_orca_output(output_file)
            
            # Display results
            st.divider()
            st.header("üìä Results")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("‚ö° Final Energy")
                st.metric("Energy", f"{energy} Eh", help="Total electronic energy in Hartrees (Eh)")
                st.caption("Lower energy = more stable structure")
            
            with col2:
                st.subheader("üî¨ Optimized Geometry")
                st.caption("Final atomic coordinates (√Öngstr√∂ms)")
                st.code(optimized_geometry, language=None)
            
            # Full ORCA output in expandable section
            st.divider()
            st.subheader("üìÑ Full ORCA Output")
            st.markdown("Expand below to see the complete ORCA output including the ASCII art logo and detailed calculation information.")
            
            with st.expander("View Complete ORCA Output", expanded=False):
                st.text_area(
                    "ORCA Output",
                    value=full_output,
                    height=400,
                    label_visibility="collapsed"
                )
            
            # Download section
            st.divider()
            st.subheader("üíæ Download Results")
            st.markdown("Download the complete ORCA output file for further analysis or record keeping.")
            st.download_button(
                label="üì• Download ORCA Output File",
                data=full_output,
                file_name="orca_output.out",
                mime="text/plain",
                use_container_width=True
            )

if __name__ == "__main__":
    main()
